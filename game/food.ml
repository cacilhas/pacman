let base = String.concat ""
  [ "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
  ; "\x00\x01\x01\x01\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x01\x01\x01\x00"
  ; "\x00\x02\x00\x00\x01\x00\x00\x00\x01\x00\x01\x00\x00\x00\x01\x00\x00\x02\x00"
  ; "\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x00"
  ; "\x00\x01\x00\x00\x01\x00\x01\x00\x00\x00\x00\x00\x01\x00\x01\x00\x00\x01\x00"
  ; "\x00\x01\x01\x01\x01\x00\x01\x01\x00\x00\x00\x01\x01\x00\x01\x01\x01\x01\x00"
  ; "\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  ; "\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  ; "\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  ; "\x00\x00\x00\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x00\x00\x00"
  ; "\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  ; "\x00\x00\x00\x00\x01\x00\x00\x00\x00\x03\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  ; "\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  ; "\x00\x01\x01\x01\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x01\x01\x01\x00"
  ; "\x00\x01\x00\x00\x01\x00\x00\x00\x01\x00\x01\x00\x00\x00\x01\x00\x00\x01\x00"
  ; "\x00\x02\x01\x00\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x00\x01\x02\x00"
  ; "\x00\x00\x01\x00\x01\x00\x01\x00\x00\x00\x00\x00\x01\x00\x01\x00\x01\x00\x00"
  ; "\x00\x01\x01\x01\x01\x00\x01\x01\x01\x00\x01\x01\x01\x00\x01\x01\x01\x01\x00"
  ; "\x00\x01\x00\x00\x00\x00\x00\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x01\x00"
  ; "\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x00"
  ; "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
  ]

let map = Array.init (String.length base) (fun _ -> '\x00')

type fruit = {
  mutable show : bool
; mutable time : float
}

let cherry = {
  show = false
; time = 0.0
}

let reset ~show =
  cherry.time <- 0.0
; cherry.show <- show

let resting () = Array.map int_of_char map
              |> Array.map (fun e -> if e = 3 then 0 else e)
              |> Array.fold_left Int.add 0

let index_of_xy x y =
  if x < 0 || x > 18 || y < 0 || y > 20
  then 0
  else y*19 + x

let get_cell (x, y) =
  let value = int_of_char map.(index_of_xy x y) in
  if value = 3
  then begin
    if cherry.show
    then 3
    else 0
  end
  else value

let eaten i =
  if map.(i) = '\x03'
  then reset ~show:false
  else map.(i) <- '\x00'

let eat = function
  | [`Pair (x, y)] -> get_cell (x, y) |> Globals.score |> ignore
                    ; eaten (index_of_xy x y)
                    ; if resting () = 0
                      then Signal.emit "levelup" []
  | _              -> ()

let restart _ =
  String.iteri (fun i c -> map.(i) <- c) base

let update = function
  | [`Float dt] -> cherry.time <- cherry.time +. dt
                 ; if cherry.show
                   then begin
                     if cherry.time > 8.0
                     then reset ~show:false
                   end
                   else begin
                     if cherry.time > 12.0 && Random.int 100 > 90
                     then reset ~show:true
                   end
  | _           -> ()

let connect_handles () =
  Signal.connect "gotta"   eat     |> ignore
; Signal.connect "levelup" restart |> ignore
; Signal.connect "restart" restart |> ignore
; Signal.connect "update"  update  |> ignore

let () = restart []
